<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>화상상담</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        #videoContainer {
            position: relative;
            width: 80%;
            height: 80%;
            background-color: #000;
        }
        #localStream {
            position: absolute;
            width: 20%;
            height: 20%;
            bottom: 20px;
            right: 20px;
            z-index: 2;
            border: 2px solid #fff;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #remoteStreamDiv {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #remoteStreamDiv video {
            max-width: 100%;
            max-height: 100%;
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
        }

        .notification {
            background-color: #4CAF50;
            color: white;
            padding: 10px;
            margin: 5px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
<div id="videoContainer">
    <video id="localStream" autoplay playsinline controls style="display: none;"></video>
    <div id="remoteStreamDiv"></div>
</div>
<div id="notificationArea"></div>
<div id="controls">
    <button class="btn btn-outline-success" id="startStreamBtn">상담시작</button>&nbsp;&nbsp;
    <button class="btn btn-outline-danger" id="toggleCameraBtn">카메라On</button>&nbsp;&nbsp;
    <button class="btn btn-outline-danger" id="toggleMicBtn">마이크On</button>
</div>
<script>
    let localStreamElement = document.querySelector('#localStream');
    const myKey = Math.random().toString(36).substring(2, 11);
    let pcListMap = new Map();
    let roomId;
    let otherKeyList = [];
    let localStream = undefined;
    let stompClient;

    const startCam = async () => {
        if (navigator.mediaDevices !== undefined) {
            await navigator.mediaDevices.getUserMedia({ audio: true, video: true })
                .then(async (stream) => {
                    localStream = stream;
                    stream.getAudioTracks()[0].enabled = true;
                    localStreamElement.srcObject = localStream;
                })
                .catch(error => {
                    console.error("Error accessing media devices:", error);
                });
        }
    }

    const connectSocket = async () => {
        const socket = new SockJS('/signaling/video');
        //const socket = new SockJS('http://192.168.219.106/8443/signaling');
        stompClient = Stomp.over(socket);
        stompClient.debug = null;

        stompClient.connect({}, function () {
            console.log('WebRTC 연결 성공');

            stompClient.subscribe(`/topic/peer/iceCandidate/${myKey}/${roomId}`, candidate => {
                const key = JSON.parse(candidate.body).key;
                const message = JSON.parse(candidate.body).body;
                console.log('Received ICE candidate from:', key, message);
                if (pcListMap.has(key)) {
                    pcListMap.get(key).addIceCandidate(new RTCIceCandidate(message));
                }
            });

            stompClient.subscribe(`/topic/peer/offer/${myKey}/${roomId}`, offer => {
                const key = JSON.parse(offer.body).key;
                const message = JSON.parse(offer.body).body;
                console.log('Received offer from:', key, message);
                if (!pcListMap.has(key)) {
                    pcListMap.set(key, createPeerConnection(key));
                }
                const pc = pcListMap.get(key);
                pc.setRemoteDescription(new RTCSessionDescription(message));
                sendAnswer(pc, key);
            });

            stompClient.subscribe(`/topic/peer/answer/${myKey}/${roomId}`, answer => {
                const key = JSON.parse(answer.body).key;
                const message = JSON.parse(answer.body).body;
                console.log('Received answer from:', key, message);
                if (pcListMap.has(key)) {
                    pcListMap.get(key).setRemoteDescription(new RTCSessionDescription(message));
                }
            });

            stompClient.subscribe(`/topic/call/key`, () => {
                console.log('Requesting keys...');
                stompClient.send(`/app/send/key`, {}, JSON.stringify(myKey));
            });

            stompClient.subscribe(`/topic/send/key`, message => {
                const key = JSON.parse(message.body);
                console.log('Received key:', key);
                if (myKey !== key && !otherKeyList.includes(key)) {
                    otherKeyList.push(key);
                    console.log('Added key to otherKeyList:', key);
                    // 상대방 입장 알림을 시각적으로 표시
                    showNotification(`상대방이 입장했습니다: ${key}`);
                }
            });
        });
    }

    // 알림을 시각적으로 표시하는 함수
    const showNotification = (message) => {
        const notificationArea = document.querySelector('#notificationArea');
        const notification = document.createElement('div');
        notification.classList.add('notification');
        notification.textContent = message;
        notificationArea.appendChild(notification);
        setTimeout(() => {
            notification.remove();
        }, 5000); // 5초 후에 알림을 제거
    }

    const createPeerConnection = (otherKey) => {
        const pc = new RTCPeerConnection();
        try {
            pc.addEventListener('icecandidate', event => {
                onIceCandidate(event, otherKey);
            });
            pc.addEventListener('track', event => {
                onTrack(event, otherKey);
            });
            if (localStream !== undefined) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }
            console.log('PeerConnection created for key:', otherKey);
        } catch (error) {
            console.error('PeerConnection failed: ', error);
        }
        return pc;
    }

    let onIceCandidate = (event, otherKey) => {
        if (event.candidate) {
            console.log('ICE candidate');
            stompClient.send(`/app/peer/iceCandidate/${otherKey}/${roomId}`, {}, JSON.stringify({
                key: myKey,
                body: event.candidate
            }));
        }
    };

    let sendOffer = (pc, otherKey) => {
        pc.createOffer().then(offer => {
            setLocalAndSendMessage(pc, offer);
            stompClient.send(`/app/peer/offer/${otherKey}/${roomId}`, {}, JSON.stringify({
                key: myKey,
                body: offer
            }));
            console.log('Send offer to key:', otherKey);
        });
    };

    let sendAnswer = (pc, otherKey) => {
        pc.createAnswer().then(answer => {
            setLocalAndSendMessage(pc, answer);
            stompClient.send(`/app/peer/answer/${otherKey}/${roomId}`, {}, JSON.stringify({
                key: myKey,
                body: answer
            }));
            console.log('Send answer to key:', otherKey);
        });
    };

    const setLocalAndSendMessage = (pc, sessionDescription) => {
        pc.setLocalDescription(sessionDescription);
    }

    let onTrack = (event, otherKey) => {
        console.log('onTrack event from key:', otherKey, event);
        if (document.getElementById(`${otherKey}`) === null) {
            const video = document.createElement('video');
            video.autoplay = true;
            video.controls = true;
            video.id = otherKey;
            video.srcObject = event.streams[0];
            document.getElementById('remoteStreamDiv').appendChild(video);
        }
    };

    window.onload = async function() {
        const urlParams = new URLSearchParams(window.location.search);
        roomId = urlParams.get('roomId');
        if (roomId) {
            await startCam();
            if (localStream !== undefined) {
                localStreamElement.style.display = 'block';
                await connectSocket();
                console.log('Requesting initial keys...');
                stompClient.send(`/app/call/key`, {}, {});
            }
        }
    };

    document.querySelector('#startStreamBtn').addEventListener('click', async () => {
        const startStreamBtn = document.querySelector('#startStreamBtn');
        stompClient.send(`/app/call/key`, {}, {});
        setTimeout(() => {
            otherKeyList.forEach((key) => {
                if (!pcListMap.has(key)) {
                    pcListMap.set(key, createPeerConnection(key));
                    sendOffer(pcListMap.get(key), key);
                }
            });
            // "시작하기" 버튼 텍스트와 스타일 변경
            startStreamBtn.textContent = '상담중';
            startStreamBtn.classList.add('active');
            startStreamBtn.disabled = true; // 버튼 비활성화
        }, 1000);
    });

    // 카메라 켜고 끄는 기능
    document.querySelector('#toggleCameraBtn').addEventListener('click', async () => {
        if (localStream) {
            const videoTrack = localStream.getVideoTracks()[0];
            const toggleCameraBtn = document.querySelector('#toggleCameraBtn');
            if (videoTrack.enabled) {
                videoTrack.enabled = false;
                toggleCameraBtn.textContent = '카메라Off';
                toggleCameraBtn.classList.remove('active');
                console.log('카메라를 끕니다.');
            } else {
                videoTrack.enabled = true;
                toggleCameraBtn.textContent = '카메라On';
                toggleCameraBtn.classList.add('active');
                console.log('카메라를 켭니다.');
            }
        }
    });

    // 마이크 켜고 끄는 기능
    document.querySelector('#toggleMicBtn').addEventListener('click', async () => {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            const toggleMicBtn = document.querySelector('#toggleMicBtn');
            if (audioTrack.enabled) {
                audioTrack.enabled = false;
                toggleMicBtn.textContent = '마이크Off';
                toggleMicBtn.classList.remove('active');
                console.log('마이크를 끕니다.');
            } else {
                audioTrack.enabled = true;
                toggleMicBtn.textContent = '마이크On';
                toggleMicBtn.classList.add('active');
                console.log('마이크를 켭니다.');
            }
        }
    });
</script>
</body>
</html>
